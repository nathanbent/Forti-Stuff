#!/usr/bin/env python3
import re
import socket
import ipaddress
from datetime import datetime
from typing import Optional

# ==========================================================
# Config
# ==========================================================

# ----------------------------
# Input mode
# ----------------------------
# False = one FQDN per non-empty line
# True  = pairs: line1=name, line2=fqdn
USE_EXPLICIT_NAMES = False

# ----------------------------
# Object naming
# ----------------------------
ENABLE_PREFIX = True
NAME_PREFIX = "NTP - "

# For generated /32 IP objects:
# True:  <base-name>-ip-1, -ip-2, ...
# False: <base-name>-<ip> (dots -> underscores)
IP_OBJECTS_USE_INDEX = True
IP_OBJECT_SUFFIX = "-IP-"  # used only when IP_OBJECTS_USE_INDEX=True

# Optional: force fqdn lowercase
LOWERCASE_FQDN = False

# ----------------------------
# Output behavior
# ----------------------------
OUTPUT_FQDN_OBJECTS = True
OUTPUT_IP_OBJECTS = True          # resolve A records and create /32 objects
MAX_IPS_PER_FQDN = 20             # safety limit per FQDN (CDNs can return lots)
DNS_TIMEOUT_SECONDS = 3.0

# ----------------------------
# Output headers/footers
# ----------------------------
START_WITH_CONFIG_FIREWALL_ADDRESS = True  # writes: config firewall address
END_CONFIG_FIREWALL_ADDRESS = True         # writes: end

# ==========================================================
# FortiOS address object options (toggles + values)
# Rule: for enable/disable style fields, we only emit "... enable" when toggled on.
# If toggled off, we omit the line entirely.
# ==========================================================

# comment
ENABLE_COMMENT = True

# Comment for FQDN objects only (no resolver timestamp)
COMMENT_TEMPLATE_FQDN = ""

# Comment for resolved IP (/32) objects only (includes resolver timestamp)
COMMENT_TEMPLATE_IP = "Resolved from {fqdn} | ip={ip} | resolved_at={resolved_at}"

# associated-interface: Network interface associated with address.
ENABLE_ASSOCIATED_INTERFACE = False
ASSOCIATED_INTERFACE = "port1"

# color: Color of icon on the GUI.
ENABLE_COLOR = True
COLOR_ID = 30

# allow-routing: Enable use of this address in routing configurations.
ENABLE_ALLOW_ROUTING = False

# passive-fqdn-learning: Enable passive learning of FQDNs (FQDN objects only).
ENABLE_PASSIVE_FQDN_LEARNING = False

# cache-ttl: Minimal TTL of individual IPs in FQDN cache (seconds) (FQDN objects only).
ENABLE_CACHE_TTL = False
CACHE_TTL_SECONDS = 300

# fabric-object: Security Fabric global object setting.
ENABLE_FABRIC_OBJECT = False

# ==========================================================
# Address Group (addrgrp) options
# ==========================================================
ENABLE_ALL_OBJECTS_GROUP = True
ALL_OBJECTS_GROUP_NAME = "Trusted NTP Servers"

# type: Address group type. (FortiOS commonly "default")
ENABLE_GROUP_TYPE = False
GROUP_TYPE = "default"

# category: Address group category. (FortiOS commonly "default", "ztna-ems-tag", "ztna-geo-tag")
ENABLE_GROUP_CATEGORY = False
GROUP_CATEGORY = "default"

# comment
ENABLE_GROUP_COMMENT = False
GROUP_COMMENT_TEMPLATE = "Generated by resolver script at {resolved_at}"

# color
ENABLE_GROUP_COLOR = True
GROUP_COLOR_ID = 30

# fabric-object (enable-only)
ENABLE_GROUP_FABRIC_OBJECT = False

# ==========================================================
# Resolver run timestamp (once per script run)
# ==========================================================
RESOLVED_AT = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")


# ==========================================================
# Helpers
# ==========================================================

def strip_inline_comment(s: str) -> str:
    return re.split(r"[#;]", s, maxsplit=1)[0].strip()


def safe_obj_name(name: str) -> str:
    n = name.replace('"', "").replace("\n", " ").strip()
    n = re.sub(r"\s+", " ", n)
    if not n:
        raise ValueError("empty object name")
    return n


def validate_fqdn(fqdn: str) -> str:
    f = fqdn.strip().strip('"').strip("'")
    if LOWERCASE_FQDN:
        f = f.lower()

    if not f:
        raise ValueError("empty fqdn")
    if any(ch.isspace() for ch in f):
        raise ValueError("fqdn contains whitespace")

    # Allow wildcard prefix: *.example.com (but we won't resolve it)
    candidate = f[2:] if f.startswith("*.") else f

    # Disallow URL-ish input
    if "://" in candidate or "/" in candidate:
        raise ValueError("fqdn looks like a URL; provide host only (e.g., example.com)")

    labels = candidate.split(".")
    if len(labels) < 2:
        raise ValueError("fqdn must contain a dot (e.g., example.com)")

    allowed = re.compile(r"^[A-Za-z0-9-]+$")
    for lab in labels:
        if not lab:
            raise ValueError("fqdn has an empty label (..)")
        if len(lab) > 63:
            raise ValueError("fqdn label too long (>63)")
        if lab.startswith("-") or lab.endswith("-"):
            raise ValueError("fqdn label cannot start/end with '-'")
        if not allowed.match(lab):
            raise ValueError(f"fqdn label has invalid chars: {lab!r}")

    return f


def build_base_name(name_from_input: Optional[str], fqdn: str) -> str:
    base = name_from_input if USE_EXPLICIT_NAMES else fqdn
    base = safe_obj_name(base)

    if ENABLE_PREFIX and NAME_PREFIX:
        return safe_obj_name(f"{NAME_PREFIX}{base}")

    return base


def make_ip_obj_name(base_name: str, ip: str, idx: int) -> str:
    if IP_OBJECTS_USE_INDEX:
        return safe_obj_name(f"{base_name}{IP_OBJECT_SUFFIX}{idx}")
    ip_tag = ip.replace(".", "_")
    return safe_obj_name(f"{base_name}-{ip_tag}")


def resolve_ipv4_a_records(host: str) -> list[str]:
    """
    Resolve IPv4 A records using system resolver.
    Returns unique, sorted IP strings.
    """
    socket.setdefaulttimeout(DNS_TIMEOUT_SECONDS)
    results = socket.getaddrinfo(host, None, family=socket.AF_INET, type=socket.SOCK_STREAM)
    ips = sorted({r[4][0] for r in results})

    good: list[str] = []
    for ip in ips:
        try:
            ipaddress.ip_address(ip)
            good.append(ip)
        except Exception:
            pass

    return good[:MAX_IPS_PER_FQDN]


def load_meaningful_lines(input_file: str) -> list[str]:
    lines: list[str] = []
    with open(input_file, "r", encoding="utf-8") as f:
        for raw in f:
            cleaned = strip_inline_comment(raw)
            if cleaned:
                lines.append(cleaned)
    return lines


def iter_records(lines: list[str]):
    """
    Yields tuples: (lineno, name_line_or_none, fqdn_line)
    """
    if USE_EXPLICIT_NAMES:
        if len(lines) % 2 != 0:
            print(
                f"Warning: input has an odd number of non-empty lines ({len(lines)}). "
                f"The last line will be ignored: '{lines[-1]}'"
            )
        for i in range(0, len(lines) - 1, 2):
            name_line = lines[i].strip().strip('"')
            fqdn_line = lines[i + 1].strip()
            yield (i + 1, name_line, fqdn_line)
    else:
        for lineno, fqdn_line in enumerate(lines, start=1):
            yield (lineno, None, fqdn_line)


# ==========================================================
# Comment rendering (separate for FQDN vs resolved IP objects)
# ==========================================================

def render_address_comment(*, fqdn: str, ip: Optional[str]) -> Optional[str]:
    if not ENABLE_COMMENT:
        return None

    if ip is None:
        return COMMENT_TEMPLATE_FQDN.format(fqdn=fqdn)

    return COMMENT_TEMPLATE_IP.format(fqdn=fqdn, ip=ip, resolved_at=RESOLVED_AT)


# ==========================================================
# FortiOS write helpers (address objects)
# ==========================================================

def write_address_common_options(out, *, fqdn: str, ip: Optional[str], is_fqdn_obj: bool) -> None:
    # comment
    comment = render_address_comment(fqdn=fqdn, ip=ip)
    if comment:
        comment = comment.replace('"', "'")
        out.write(f'set comment "{comment}"\n')

    # associated-interface
    if ENABLE_ASSOCIATED_INTERFACE and ASSOCIATED_INTERFACE:
        out.write(f'set associated-interface "{ASSOCIATED_INTERFACE}"\n')

    # color
    if ENABLE_COLOR:
        out.write(f"set color {int(COLOR_ID)}\n")

    # allow-routing (emit only enable)
    if ENABLE_ALLOW_ROUTING:
        out.write("set allow-routing enable\n")

    # fabric-object (emit only enable)
    if ENABLE_FABRIC_OBJECT:
        out.write("set fabric-object enable\n")

    # FQDN-only options
    if is_fqdn_obj:
        if ENABLE_PASSIVE_FQDN_LEARNING:
            out.write("set passive-fqdn-learning enable\n")
        if ENABLE_CACHE_TTL:
            out.write(f"set cache-ttl {int(CACHE_TTL_SECONDS)}\n")


def write_fqdn_object(out, obj_name: str, fqdn: str) -> None:
    out.write(f'edit "{obj_name}"\n')
    out.write("set type fqdn\n")
    out.write(f'set fqdn "{fqdn}"\n')
    write_address_common_options(out, fqdn=fqdn, ip=None, is_fqdn_obj=True)
    out.write("next\n\n")


def write_ip_object(out, obj_name: str, fqdn: str, ip: str) -> None:
    out.write(f'edit "{obj_name}"\n')
    out.write(f"set subnet {ip} 255.255.255.255\n")
    write_address_common_options(out, fqdn=fqdn, ip=ip, is_fqdn_obj=False)
    out.write("next\n\n")


# ==========================================================
# FortiOS write helpers (addrgrp)
# ==========================================================

def write_addrgrp(out, group_name: str, members: list[str]) -> None:
    if not members:
        return

    out.write("config firewall addrgrp\n")
    out.write(f'edit "{safe_obj_name(group_name)}"\n')

    if ENABLE_GROUP_TYPE and GROUP_TYPE:
        out.write(f"set type {GROUP_TYPE}\n")

    if ENABLE_GROUP_CATEGORY and GROUP_CATEGORY:
        out.write(f"set category {GROUP_CATEGORY}\n")

    if ENABLE_GROUP_COMMENT and GROUP_COMMENT_TEMPLATE:
        c = GROUP_COMMENT_TEMPLATE.format(resolved_at=RESOLVED_AT).replace('"', "'")
        out.write(f'set comment "{c}"\n')

    if ENABLE_GROUP_COLOR:
        out.write(f"set color {int(GROUP_COLOR_ID)}\n")

    if ENABLE_GROUP_FABRIC_OBJECT:
        out.write("set fabric-object enable\n")

    # FortiOS addrgrp member list: set member "a" "b" "c"
    # (If this line gets extremely long, reduce MAX_IPS_PER_FQDN or disable IP objects.)
    quoted = " ".join(f'"{m}"' for m in members)
    out.write(f"set member {quoted}\n")

    out.write("next\n")
    out.write("end\n")


# ==========================================================
# Main
# ==========================================================

def format_fqdn_and_ip_objects(input_file: str, output_file: str) -> None:
    written_fqdn = 0
    written_ip = 0
    skipped = 0

    created_objects: list[str] = []  # for optional group

    lines = load_meaningful_lines(input_file)

    with open(output_file, "w", encoding="utf-8") as out:
        # Header: config firewall address
        if START_WITH_CONFIG_FIREWALL_ADDRESS:
            out.write("config firewall address\n")

        # Address objects
        for lineno, name_line, fqdn_line in iter_records(lines):
            try:
                fqdn = validate_fqdn(fqdn_line)
                base_name = build_base_name(name_line, fqdn)

                # 1) FQDN object
                if OUTPUT_FQDN_OBJECTS:
                    write_fqdn_object(out, base_name, fqdn)
                    created_objects.append(base_name)
                    written_fqdn += 1

                # 2) Resolved IP (/32) objects
                if OUTPUT_IP_OBJECTS:
                    if fqdn.startswith("*."):
                        print(f"[Line {lineno}] Wildcard '{fqdn}' not resolvable; skipping IP objects.")
                        continue

                    try:
                        ips = resolve_ipv4_a_records(fqdn)
                    except Exception as e:
                        print(f"[Line {lineno}] DNS resolve failed for '{fqdn}': {e}")
                        continue

                    if not ips:
                        print(f"[Line {lineno}] No IPv4 A records found for '{fqdn}'.")
                        continue

                    for idx, ip in enumerate(ips, start=1):
                        ip_obj_name = make_ip_obj_name(base_name, ip, idx)
                        write_ip_object(out, ip_obj_name, fqdn, ip)
                        created_objects.append(ip_obj_name)
                        written_ip += 1

            except Exception as e:
                skipped += 1
                who = f"name='{name_line}' " if name_line is not None else ""
                print(f"[Line {lineno}] Skipped {who}fqdn='{fqdn_line}': {e}")

        # Footer: end (for config firewall address)
        if END_CONFIG_FIREWALL_ADDRESS:
            out.write("end\n\n")

        # Optional: create a group containing all created objects
        if ENABLE_ALL_OBJECTS_GROUP:
            write_addrgrp(out, ALL_OBJECTS_GROUP_NAME, created_objects)

    print(
        f"Done.\n"
        f"  Wrote FQDN objects: {written_fqdn}\n"
        f"  Wrote IP objects:   {written_ip}\n"
        f"  Skipped:            {skipped}\n"
        f"  Total objects:      {len(created_objects)}\n"
        f"  Resolver timestamp: {RESOLVED_AT} (UTC)\n"
        f"  Group created:      {'yes' if ENABLE_ALL_OBJECTS_GROUP else 'no'}"
    )


if __name__ == "__main__":
    format_fqdn_and_ip_objects("input.txt", "output.txt")
